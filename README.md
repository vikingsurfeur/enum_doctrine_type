# Doctrine Enum Type Handler

Une implÃ©mentation robuste pour utiliser les enums PHP 8.1+ comme types personnalisÃ©s dans Doctrine ORM avec PostgreSQL.

## ğŸ“‹ PrÃ©sentation

Ce projet fournit un ensemble de classes permettant d'utiliser les enums PHP comme types natifs dans PostgreSQL via Doctrine. La solution garantit l'intÃ©gritÃ© des donnÃ©es en crÃ©ant des types enum personnalisÃ©s dans PostgreSQL qui correspondent directement aux valeurs de vos enums PHP.

### CaractÃ©ristiques

- âœ… Support complet des backed enums et des enums classiques
- âœ… Validation cÃ´tÃ© base de donnÃ©es via des contraintes PostgreSQL natives
- âœ… Conversion automatique entre les reprÃ©sentations PHP et SQL
- âœ… Architecture extensible suivant les principes SOLID
- âœ… Tests unitaires et d'intÃ©gration complets

## ğŸš€ Installation

### PrÃ©requis

- PHP 8.1+
- Symfony 6.0+
- Doctrine ORM
- PostgreSQL

### Configuration

1. Clonez ce dÃ©pÃ´t ou copiez les fichiers dans votre projet

2. Enregistrez les types personnalisÃ©s dans le fichier de configuration Doctrine :

```yaml
# config/packages/doctrine.yaml
doctrine:
    dbal:
        types:
            task_priority_enum: App\Doctrine\Type\TaskPriorityEnumType
```

3. ExÃ©cutez les migrations pour crÃ©er les types enum dans PostgreSQL

## ğŸ”§ Utilisation

### 1. CrÃ©er un Enum PHP

```php
<?php
declare(strict_types=1);

namespace App\Enum;

enum TaskPriorityEnum: string
{
    case LOW = 'basse';
    case MEDIUM = 'normale';
    case HIGH = 'haute';
    case CRITICAL = 'critique';
}
```

### 2. CrÃ©er un Type Doctrine correspondant

```php
<?php
declare(strict_types=1);

namespace App\Doctrine\Type;

use App\Enum\TaskPriorityEnum;

class TaskPriorityEnumType extends AbstractEnumType
{
    public const TYPE_NAME = 'task_priority_enum';
    
    public static function getTypeName(): string
    {
        return self::TYPE_NAME;
    }
    
    protected static function getEnumClass(): string
    {
        return TaskPriorityEnum::class;
    }
}
```

### 3. Utiliser le type dans une entitÃ©

```php
<?php
namespace App\Entity;

use App\Doctrine\Type\TaskPriorityEnumType;
use App\Enum\TaskPriorityEnum;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class Task
{
    #[ORM\Column(type: TaskPriorityEnumType::TYPE_NAME)]
    private ?TaskPriorityEnum $priority = null;
    
    public function getPriority(): ?TaskPriorityEnum
    {
        return $this->priority;
    }
    
    public function setPriority(TaskPriorityEnum $priority): self
    {
        $this->priority = $priority;
        return $this;
    }
}
```

### 4. CrÃ©er une migration

La migration doit crÃ©er le type enum PostgreSQL avant de crÃ©er les tables qui l'utilisent :

```php
<?php
declare(strict_types=1);

namespace DoctrineMigrations;

use App\Doctrine\Type\TaskPriorityEnumType;
use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

final class Version20250319040536 extends AbstractMigration
{
    public function getDescription(): string
    {
        return 'Task / TaskPriorityEnumType';
    }
    
    public function up(Schema $schema): void
    {
        // CrÃ©er d'abord le type enum
        $this->addSql(TaskPriorityEnumType::getCreateTypeSQL());
        
        // Puis crÃ©er la table qui l'utilise
        $this->addSql('CREATE TABLE task (
            id INT GENERATED BY DEFAULT AS IDENTITY NOT NULL, 
            name VARCHAR(255) NOT NULL, 
            created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, 
            priority task_priority_enum NOT NULL, 
            PRIMARY KEY(id)
        )');
    }
    
    public function down(Schema $schema): void
    {
        $this->addSql('DROP TABLE task');
        $this->addSql(TaskPriorityEnumType::getDropTypeSQL());
    }
}
```

## ğŸ’» Fonctionnement interne

### Architecture

Le systÃ¨me repose sur trois composants principaux :

1. **AbstractEnumType** : Classe abstraite gÃ©rant la conversion entre PHP et SQL
2. **EnumTypeHelper** : Classe utilitaire pour gÃ©nÃ©rer le SQL nÃ©cessaire aux types enum PostgreSQL
3. **Types concrets** (ex: TaskPriorityEnumType) : ImplÃ©mentations spÃ©cifiques pour chaque enum

### Flux de donnÃ©es

1. En lecture, les valeurs de la base de donnÃ©es sont converties en instances d'enum PHP
2. En Ã©criture, les instances d'enum PHP sont converties en chaÃ®nes pour la base de donnÃ©es
3. PostgreSQL valide que les valeurs correspondent bien aux valeurs autorisÃ©es par le type enum

## ğŸ§ª Tests

Le projet inclut des tests unitaires et d'intÃ©gration pour garantir le bon fonctionnement.

### ExÃ©cution des tests

```bash
# Installer les dÃ©pendances de dÃ©veloppement
composer require --dev phpunit/phpunit symfony/test-pack

# ExÃ©cuter tous les tests
./vendor/bin/phpunit

# ExÃ©cuter uniquement les tests unitaires
./vendor/bin/phpunit --testsuite Unit

# ExÃ©cuter uniquement les tests d'intÃ©gration
./vendor/bin/phpunit --testsuite Integration
```

## ğŸ¤ Contribution

Les contributions sont les bienvenues ! N'hÃ©sitez pas Ã  ouvrir une issue ou une pull request.

### Principes de dÃ©veloppement

Ce projet suit les principes SOLID et les bonnes pratiques de Clean Code :

- **S**ingle Responsibility : Chaque classe a une responsabilitÃ© unique
- **O**pen/Closed : Le systÃ¨me est ouvert Ã  l'extension mais fermÃ© Ã  la modification
- **L**iskov Substitution : Les sous-types sont substituables Ã  leurs types de base
- **I**nterface Segregation : Les interfaces sont spÃ©cifiques Ã  leurs clients
- **D**ependency Inversion : DÃ©pendance vers les abstractions, non les implÃ©mentations

## ğŸ“„ Licence

Ce projet est sous licence MIT. Voir le fichier LICENSE pour plus d'informations.